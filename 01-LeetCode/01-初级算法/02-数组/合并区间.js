/**
 题目：合并区间；
 题干：以数组 intervals 表示若干个区间的集合，
   其中单个区间为 intervals[i] = [starti, endi] 。
   请你合并所有重叠的区间，并返回 一个不重叠的区间数组，
   该数组需恰好覆盖输入中的所有区间 。
  
 示例 1：
    输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
    输出：[[1,6],[8,10],[15,18]]
    解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

 示例 2：
    输入：intervals = [[1,4],[4,5]]
    输出：[[1,5]]
    解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 */

/**
正确分析：
    1. 涉及到数组内部比较大小，可以先保证左0永远比右0小；-》数组排序，从小到大排列；
    2. 将pre放在循环外面，相对循环比较独立，不会每次重新赋值；
    3. 新建一个数组，用于存放可靠结果；
    4. 开始循环，注意需要从下标[1]开始，因为0已经在循环外部定义过了；
    5. 比较pre最大值和cur最小值的大小：
        5.1 如果pre最大值小于cur最小值，那么说明pre和cur没有交集，而后面的值都是比cur[0]要大的，所以也不会和后面的值有交集；
            可以将pre直接push至result中，并将cur赋值给pre，变成新的pre；
        5.2 如果pre最大值大于或等于cur最小值，，这个时候，下限肯定是pre[0]了。
            上限不确定，pre[1]也有可能大于cur[1]，可知的是，上限必须是其中的最大值；
    6. 最后等循环全部结束，还是会有一个新的pre，push至result中；
核心：
    1. 数组排序，保证pre[0]小于cur[0]，也小于后面任何[0]；
    2. 循环判断，主要比较pre[1]和cur[0]的大小，如果pre小，那么将pre添加至result中，赋值cur为新的pre，进入下一轮循环；如果pre大，就和cur[1]比较大小，取最大值；
 */ 

const merge = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);

    const pre = intervals[0];
    const result = [];

    for (let i = 1; i < intervals.length; i++) {
        let cur = intervals[i];
        if (pre[1] >= cur[0]) {
            pre[1] = Math.max(pre[1], cur[1]);
        } else {
            result.push(pre);
            pre = cur;
        }
    }

    result.push(pre);
    return result;
}









/**
 错误分析：
1. 新建一个数组，用于保存变更后的合并项；
2. 进行双重循环，外层循环用于遍历被比较数组项；内层循环用于遍历比较数组项；
    比较完成之后，将结果数组push至新数组中；
3. 比较可能的情况：
   A. 当左0小于右0的时候：
       a. 左1小于右0：
   3.1 左0 < 左1 < 右0 < 右1；     返回：[[左0，左1],[右0，右1]]
       b.左1大于等于右0，但小于右1：
   3.2 左0 < 右0 <= 左1 < 右1；    返回：[左0，右1]；
       c. 左1大于等于右0，且大于等于右1：
   3.3 左0 < 右0 < 右1 <= 左1；    返回：[左0，左1]；
   B. 当右0小于左0的时候：
   3.4 右0 < 右1 < 左0 < 左1；     返回：[[左0，左1],[右0，右1]]
       a. 右1大于左0，但小于左1； 
   3.5 右0 < 左0 < 右1 < 左1；     返回：[右0，左1]
       b. 右1大于左0，且大于左1；
   3.6 右0 < 左0 < 左1 < 右1；     返回：[右0，右1]
4. 发现：左边和右边其实可以调换，位置不受影响；
    那么可以减少B下面的判断，
    如果右0小于左0的时候，左右调换一下，就可以避免走B下面的判断了；
 * */ 

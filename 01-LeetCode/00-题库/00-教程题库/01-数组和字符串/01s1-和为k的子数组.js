/**
题目：和为k的子数组
描述：
    给定一个整数数组nums和一个整数k，返回该数组中，和为k的子数组个数；
    子数组是数组中元素的 连续非空 序列；

示例 1：
    输入：nums = [1,1,1], k = 2
    输出：2

示例 2：
    输入：nums = [1,2,3], k = 3
    输出：2
 */ 

/**
读题思路：
    1. 找等式关系：[n1 + n2 + ... + ny] = k
        转化等式关系：k - n1 = n2 + ... ny
        循环等式关系：k - n1 - ... nx = ny
    2. 两层循环：
        外循环：定位起始位置；
        内循环：循环添加加数；
    3. 循环内容：
        3.1 由于等式关系存在，第一次循环的时候，已经能确定k和n1；
        3.2 在循环外，
            3.2.1 内层循环外：添加一个diff，记录差值，判断内层循环时，nx === diff ？如果不等于，就继续循环，直至结束；
            3.2.2 外层循环外：添加一个count，记录满足nx === diff的次数；
*/ 

// 暴力解法1
function test1(nums, k) {
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        let diff = k - nums[i];
        if (diff === 0) {
            count++;
        }
        for (let j = i + 1; j < nums.length; j++) {
            if (diff === nums[j]) {
                count++;
            }
            diff -= nums[j];
        }
    }
    return count;
}

console.log(test1([1,1,1], 2));

/**
前言：暴力解法，通过双层循环，会导致一个问题，就是时间复杂度变成O(n²);
目的：降低复杂度，减少循环层数；
本题考察内容：前缀和+哈希表
思路：
    核心：去掉外层循环，改用前缀和数组的方式；
    数据：         0 1 2  3  4  5  6  7
        1. nums = [3,4,7, 2,-3, 1, 4, 2 ]
        2. pre =  [3,7,14,16,13,14,18,20]
    1. 前缀和：pre[i]为n0+...+ni的和，pre[i]也可以从pre[i-1]得到，即pre[i] = pre[i-1] + ni
    2. pre[i] - pre[j] = n[j+1] + n[j+2] + ... + n[i];如i为4，j为1；
    3. [j,...,i]这个子数组和为k，即pre[i] - pre[j-1] = k;这里需要j-1，是因为如果是j，则j也会被减掉，那就不是[j -> i],而是[j+1 -> i];
    4. 转化一下，就是pre[i] - k = pre[j-1];
    5. 是否循环？循环，便会增加时间复杂度；
*/ 


/**
思路：
    1. 准备一个map，保存前缀和pre[i]，和达成前缀和pre[i]的个数；
        1.1 记录前缀和为0的个数为1；表示pre[i] === k的情况；
    2. 准备一个初始化的前缀和：pre = 0；和一个记录pre[i] - k = pre[j-1]的个数 count = 0； 
    3. 循环遍历每一次的num[i];
    4. 将每次的x添加至pre中，变成新的前缀和；
    5. 判断map中是否存在pre-k，如果存在，就将存在，就将pre-k的个个数加至count；

    使用前缀和的方法可以解决这个问题，因为我们需要找到和为k的连续子数组的个数。通过计算前缀和，我们可以将问题转化为求解两个前缀和之差等于k的情况。
    假设数组的前缀和数组为prefixSum，其中prefixSum[i]表示从数组起始位置到第i个位置的元素之和。那么对于任意的两个下标i和j（i < j），如果prefixSum[j] - prefixSum[i] = k，即从第i个位置到第j个位置的元素之和等于k，那么说明从第i+1个位置到第j个位置的连续子数组的和为k。
    通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和出现的次数。在遍历的过程中，我们检查是否存在prefixSum[j] - k的前缀和，如果存在，说明从某个位置到当前位置的连续子数组的和为k，我们将对应的次数累加到结果中。
    这样，通过遍历一次数组，我们可以统计出和为k的连续子数组的个数，并且时间复杂度为O(n)，其中n为数组的长度。
*/ 

// 标签：前缀和、哈希表
function subarraySum(nums, k) {
    const mp = new Map()                        // 1
    mp.set(0, 1);                               // 1.1
    let pre = 0, count = 0;                     // 2
    for (let x of nums) {
        pre += x;
        if (mp.has(pre - k)) {
            count += mp.get(pre-k)
        }
        if (mp.has(pre)) {
            mp.set(pre, mp.get(pre) + 1)
        } else {
            mp.set(pre, 1)
        }
    }
    return count;
}